## 概率

- **已知一随机发生器，产生 0 的概率是 p，产生 1 的概率是 1-p，现在要你构造一个发生器，使得它产生 0 和 1 的概率均为 1/2。**

**求解：**让该随机数生成器生成两个数，那么序列是 00，01，10，11 概率分别为 pp，p(1-p)，(1-p)p，(1-p)(1-p)。我们发现产生序列 01 以及 10 的概率是相等的，那么我们把 01 看作为 0，把 10 看作是 1，则他们产生的概论均为 p(1-p)，其他情况舍弃不用，这样就得到了0和 1 均等生成的随机器了。



- **已知有个 rand7() 的函数，返回 1 到 7 随机自然数，怎样利用这个 rand7() 构造 rand10()，随机产生出 1 到 10 的自然数。**

**求解：**如果能够得到一组等概率的数，不管是什么数，只要等概率而且个数大于 10，那么问题就可以解决了。事实上，解决方案是有无数种的，只要保证产生的结果映射到 1 到 10 的自然数后，是等概率的独立事件即可。例如， (rand7() - 1) * 7 + rand7()，可以等概率的生成 1 到 49，那么，只要把 11-49 去掉就可以了。不过这样的做法在实际使用过程中毕竟低效。因此可以去掉 41-49，然后在把 1-40 映射到 1-10 （每四个数映射为 1 个数），那么问题也就解决了。



- **掷筛子的期望 商家发明一种扔筛子游戏，顾客扔到多少点就得到多少钱，但扔筛子之前顾客需要付一定数量的钱 x，假设商家和顾客都足够聪明。**

**求解：**题目本质上是问掷一次筛子的期望以及掷两次筛子的期望。 

1. 1/6 (1 + 2 + 3 + 4 + 5 + 6) = 3.5。
2. 考虑顾客什么情况下会扔第二次，就是扔第二次得到钱变多的概率相对较大的时候，那么当顾客第一次扔到 1，2，3 的时候他会选择继续扔第二次，则这时候期望变为 1/6 (4+5+6) + 1/2 (1/6 (1+2+3+4+5+6)) = 4.25。



- **一枚不均匀的硬币，我抛了100次，有70次朝上，那么第101次朝上的概率是多少**
0.5

- **a,b符合[0,1]的均匀分布，求max(a,b)的期望**
设$z=max(a,b)$
z的分布函数$F(z)=P(a\leq z)P(b\leq z)=z^2$
概率密度函数$f(z)=2z$
$E(z)=\int_0^1zf(z)dz=\dfrac{2}{3} $

- **一副扑克牌，除去大小王，平均分两摊，每堆有两个A的概率**
$\dfrac{C_4^2\cdot C_{48}^{24}}{C_{52}^{26}}$

- **一副扑克牌54张，现分成3等份每份18张，问大小王出现在同一份中的概率是多少？**
$\dfrac{C_3^1C_{52}^{16}C_{36}^{18}}{C_{54}^{18}C_{36}^{18}}=\dfrac{17}{53}$

## 计算机网络

- TCP三次握手

## 操作系统

- 线程和进程的区别
- 进程间通信有什么手段
- 怎么看某个进程的CPU
- 怎么看进程监听了哪个端口
- Linux查找符合一定规则的文件名

## Python

- 字典是用什么实现的
- 字典排序
- GIL
- 迭代器相对于list的优点
- 闭包
- 装饰器
- 内存管理机制

## C++

- 虚函数

**虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。**

例：基类的指针可以通过指向派生类的引用来调用派生类里的同名函数，但却无法输出派生类独有的数据，所以才需要用到虚函数来解决这个问题。

参考链接：https://www.cnblogs.com/jianyungsun/p/6361670.html

- 野指针

野指针指向一个已经被删除的对象或者指向不可用内存区域的指针。和空指针不同，野指针不能简单通过判断NULL来避免。

## MapReduce

